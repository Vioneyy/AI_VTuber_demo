"""
discord_bot.py - Discord Bot with STT, Queue, and Audio Player
‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö: STT, Sequential Queue, Audio Playback, Lip Sync
"""

import discord
from discord.ext import commands
import asyncio
import logging
import os
from pathlib import Path
from typing import Optional

from src.core.queue_manager import QueuedMessage, MessageSource, get_queue_manager
from src.core.admin_commands import get_admin_handler
from src.adapters.audio_player import DiscordAudioPlayer

logger = logging.getLogger(__name__)


class DiscordBot:
    """Discord Bot with Voice Support"""
    
    def __init__(
        self,
        token: str,
        motion_controller=None,
        stt_system=None,
        prefix: str = "!"
    ):
        # Discord setup
        intents = discord.Intents.default()
        intents.message_content = True
        intents.voice_states = True
        intents.guilds = True
        intents.members = True
        
        self.bot = commands.Bot(command_prefix=prefix, intents=intents)
        self.token = token
        
        # Components
        self.motion_controller = motion_controller
        self.stt_system = stt_system
        self.audio_player = DiscordAudioPlayer(motion_controller)
        
        # Queue manager
        self.queue_manager = get_queue_manager()
        
        # Admin handler
        self.admin_handler = get_admin_handler()
        
        # State
        self.is_ready = False
        self.voice_client: Optional[discord.VoiceClient] = None
        
        # Setup events and commands
        self._setup_events()
        self._setup_commands()
    
    def _setup_events(self):
        """Setup Discord events"""
        
        @self.bot.event
        async def on_ready():
            logger.info(f"Discord Bot logged in as {self.bot.user.name} (id={self.bot.user.id})")
            self.is_ready = True
            
            # ‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÉ‡∏ô‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå
            for guild in self.bot.guilds:
                try:
                    me = guild.me
                    if me.display_name != self.bot.user.name:
                        await me.edit(nick=self.bot.user.name)
                        logger.info(f"‚úÖ ‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÉ‡∏ô‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå '{guild.name}' ‡πÄ‡∏õ‡πá‡∏ô '{self.bot.user.name}' ‡πÅ‡∏•‡πâ‡∏ß")
                except Exception as e:
                    logger.warning(f"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÉ‡∏ô‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå {guild.name}: {e}")
        
        @self.bot.event
        async def on_message(message):
            # ‡∏Ç‡πâ‡∏≤‡∏° message ‡∏à‡∏≤‡∏Å bot
            if message.author.bot:
                return
            
            # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô command ‡πÉ‡∏´‡πâ process
            if message.content.startswith(self.bot.command_prefix):
                await self.bot.process_commands(message)
                return
            
            # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà command ‡πÅ‡∏ï‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏Å‡∏ï‡∏¥
            # (‡πÑ‡∏°‡πà‡πÄ‡∏≠‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ñ‡∏¥‡∏ß‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡πÅ‡∏Ñ‡πà voice)
            pass
    
    def _setup_commands(self):
        """Setup Discord commands"""
        
        # === Voice Commands ===
        
        @self.bot.command(name='join')
        async def join_voice(ctx):
            """‡πÄ‡∏Ç‡πâ‡∏≤ voice channel"""
            if not ctx.author.voice:
                await ctx.send("‚ùå ‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô voice channel ‡∏Å‡πà‡∏≠‡∏ô")
                return
            
            voice_channel = ctx.author.voice.channel
            
            try:
                if ctx.voice_client:
                    await ctx.voice_client.move_to(voice_channel)
                else:
                    self.voice_client = await voice_channel.connect()
                
                await ctx.send(f"‚úÖ ‡πÄ‡∏Ç‡πâ‡∏≤ voice channel: {voice_channel.name}")
                logger.info(f"Bot ‡πÄ‡∏Ç‡πâ‡∏≤ voice channel: {voice_channel.name}")
            
            except Exception as e:
                await ctx.send(f"‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤ voice channel ‡πÑ‡∏î‡πâ: {e}")
                logger.error(f"Join voice error: {e}")
        
        @self.bot.command(name='leave')
        async def leave_voice(ctx):
            """‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å voice channel"""
            if ctx.voice_client:
                await ctx.voice_client.disconnect()
                self.voice_client = None
                await ctx.send("üëã ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å voice channel ‡πÅ‡∏•‡πâ‡∏ß")
                logger.info("Bot ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å voice channel")
            else:
                await ctx.send("‚ùå ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô voice channel")
        
        @self.bot.command(name='listen')
        async def listen_voice(ctx, duration: int = 5):
            """
            ‡∏ü‡∏±‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÅ‡∏•‡∏∞‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
            Usage: !listen [duration]
            """
            if not ctx.voice_client:
                await ctx.send("‚ùå Bot ‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô voice channel ‡∏Å‡πà‡∏≠‡∏ô (‡πÉ‡∏ä‡πâ !join)")
                return
            
            if not self.stt_system:
                await ctx.send("‚ùå STT system ‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°")
                return
            
            # ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÄ‡∏ß‡∏•‡∏≤
            duration = max(1, min(duration, 30))  # 1-30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            
            await ctx.send(f"üé§ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ü‡∏±‡∏á {duration} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ...")
            
            try:
                # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡∏∞‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á
                text = await self.stt_system.record_and_transcribe(
                    ctx.voice_client,
                    duration
                )
                
                if not text or text.strip() == "":
                    await ctx.send("‚ùå ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏¢‡∏¥‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏≠‡∏∞‡πÑ‡∏£ ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á")
                    return
                
                await ctx.send(f"üìù ‡πÑ‡∏î‡πâ‡∏¢‡∏¥‡∏ô: {text}")
                logger.info(f"STT Result: {text}")
                
                # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ñ‡∏¥‡∏ß
                message = QueuedMessage(
                    text=text,
                    source=MessageSource.DISCORD_VOICE,
                    user=str(ctx.author.id),
                    timestamp=asyncio.get_event_loop().time(),
                    metadata={
                        "username": ctx.author.name,
                        "voice_client": ctx.voice_client
                    }
                )
                await self.queue_manager.add_message(message)
                
                await ctx.send("‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡∏¥‡∏î‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö...")
            
            except Exception as e:
                await ctx.send(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {e}")
                logger.error(f"Listen error: {e}", exc_info=True)
        
        # === Admin Commands ===
        
        @self.bot.command(name='approve')
        async def approve_request(ctx, approval_id: str):
            """‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°"""
            if not self.admin_handler.is_admin(str(ctx.author.id)):
                await ctx.send("‚ùå ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ")
                return
            
            response = await self.admin_handler.handle_command(
                "approve",
                [approval_id],
                str(ctx.author.id),
                {"safety_filter": self.queue_manager}
            )
            await ctx.send(response)
        
        @self.bot.command(name='reject')
        async def reject_request(ctx, approval_id: str):
            """‡∏õ‡∏è‡∏¥‡πÄ‡∏™‡∏ò‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°"""
            if not self.admin_handler.is_admin(str(ctx.author.id)):
                await ctx.send("‚ùå ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ")
                return
            
            response = await self.admin_handler.handle_command(
                "reject",
                [approval_id],
                str(ctx.author.id),
                {"safety_filter": self.queue_manager}
            )
            await ctx.send(response)
        
        @self.bot.command(name='status')
        async def show_status(ctx):
            """‡∏î‡∏π‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö"""
            if not self.admin_handler.is_admin(str(ctx.author.id)):
                await ctx.send("‚ùå ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ")
                return
            
            response = await self.admin_handler.handle_command(
                "status",
                [],
                str(ctx.author.id),
                {"queue_manager": self.queue_manager}
            )
            await ctx.send(response)
        
        @self.bot.command(name='queue')
        async def show_queue(ctx):
            """‡∏î‡∏π‡∏Ñ‡∏¥‡∏ß"""
            if not self.admin_handler.is_admin(str(ctx.author.id)):
                await ctx.send("‚ùå ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ")
                return
            
            response = await self.admin_handler.handle_command(
                "queue",
                [],
                str(ctx.author.id),
                {"queue_manager": self.queue_manager}
            )
            await ctx.send(response)
        
        @self.bot.command(name='unlock')
        async def unlock_project(ctx, code: str):
            """‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ"""
            if not self.admin_handler.is_owner(str(ctx.author.id)):
                await ctx.send("‚ùå ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ owner ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô")
                return
            
            response = await self.admin_handler.handle_command(
                "unlock",
                [code],
                str(ctx.author.id),
                {}
            )
            await ctx.send(response)
        
        @self.bot.command(name='lock')
        async def lock_project(ctx):
            """‡∏•‡πá‡∏≠‡∏Ñ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ"""
            if not self.admin_handler.is_owner(str(ctx.author.id)):
                await ctx.send("‚ùå ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ owner ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô")
                return
            
            response = await self.admin_handler.handle_command(
                "lock",
                [],
                str(ctx.author.id),
                {}
            )
            await ctx.send(response)
        
        # === Test Commands ===
        
        @self.bot.command(name='speak')
        async def speak_test(ctx, *, text: str):
            """‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÉ‡∏´‡πâ bot ‡∏û‡∏π‡∏î"""
            if not ctx.voice_client:
                await ctx.send("‚ùå Bot ‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô voice channel ‡∏Å‡πà‡∏≠‡∏ô (‡πÉ‡∏ä‡πâ !join)")
                return
            
            await ctx.send(f"üí¨ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏π‡∏î: {text}")
            
            # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ñ‡∏¥‡∏ß‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏î‡∏™‡∏≠‡∏ö
            message = QueuedMessage(
                text=text,
                source=MessageSource.DISCORD_TEXT,
                user=str(ctx.author.id),
                timestamp=asyncio.get_event_loop().time(),
                metadata={
                    "username": ctx.author.name,
                    "voice_client": ctx.voice_client
                }
            )
            await self.queue_manager.add_message(message)
    
    async def play_audio_response(
        self,
        voice_client: discord.VoiceClient,
        audio_file: str,
        text: str
    ) -> bool:
        """
        ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏° lip sync
        
        Args:
            voice_client: Discord VoiceClient
            audio_file: path ‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏µ‡∏¢‡∏á
            text: ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏û‡∏π‡∏î
        
        Returns:
            True = ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à, False = ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß
        """
        try:
            success = await self.audio_player.play_audio_with_lipsync(
                voice_client,
                audio_file,
                text
            )
            return success
        except Exception as e:
            logger.error(f"‚ùå Play audio error: {e}", exc_info=True)
            return False
    
    async def start(self):
        """‡πÄ‡∏£‡∏¥‡πà‡∏° Discord bot"""
        try:
            logger.info("üöÄ Starting Discord bot...")
            await self.bot.start(self.token)
        except Exception as e:
            logger.error(f"‚ùå Discord bot error: {e}", exc_info=True)
    
    async def stop(self):
        """‡∏´‡∏¢‡∏∏‡∏î Discord bot"""
        try:
            if self.voice_client:
                await self.voice_client.disconnect()
            await self.bot.close()
            logger.info("‚úÖ Discord bot stopped")
        except Exception as e:
            logger.error(f"‚ùå Stop error: {e}")


# Factory function
def create_discord_bot(
    token: str,
    motion_controller=None,
    stt_system=None
) -> DiscordBot:
    """‡∏™‡∏£‡πâ‡∏≤‡∏á Discord bot instance"""
    return DiscordBot(
        token=token,
        motion_controller=motion_controller,
        stt_system=stt_system
    )