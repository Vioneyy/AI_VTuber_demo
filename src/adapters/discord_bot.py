"""
discord_bot.py - Discord Bot with Voice Connection Fix
‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤ Error 4006
"""

import discord
from discord.ext import commands
import asyncio
import logging
import os
from pathlib import Path
from typing import Optional

from src.core.queue_manager import QueuedMessage, MessageSource, get_queue_manager
from src.core.admin_commands import get_admin_handler
from src.adapters.audio_player import DiscordAudioPlayer
from src.adapters.discord_voice_fix import VoiceConnectionFixer

logger = logging.getLogger(__name__)


class DiscordBot:
    """Discord Bot with Fixed Voice Support"""
    
    def __init__(
        self,
        token: str,
        motion_controller=None,
        stt_system=None,
        auto_join_voice: bool = True,
        prefix: str = "!"
    ):
        # Check voice dependencies
        logger.info("üîç Checking voice dependencies...")
        issues = VoiceConnectionFixer.check_voice_dependencies()
        if issues:
            logger.warning("‚ö†Ô∏è Voice dependency issues found:")
            for issue in issues:
                logger.warning(f"   {issue}")
            logger.warning("üí° Install: pip install PyNaCl opuslib")
        
        # Discord setup with proper intents
        intents = discord.Intents.default()
        intents.message_content = True
        intents.voice_states = True
        intents.guilds = True
        intents.members = True
        
        self.bot = commands.Bot(command_prefix=prefix, intents=intents)
        self.token = token
        
        # Components
        self.motion_controller = motion_controller
        self.stt_system = stt_system
        self.audio_player = DiscordAudioPlayer(motion_controller)
        
        # Queue & Admin
        self.queue_manager = get_queue_manager()
        self.admin_handler = get_admin_handler()
        
        # Voice state
        self.auto_join_voice = auto_join_voice
        self.target_voice_channel_id = None
        self.voice_client: Optional[discord.VoiceClient] = None
        self.voice_reconnect_task: Optional[asyncio.Task] = None
        
        # Error tracking
        self.last_voice_error = None
        self.last_voice_close_code = None
        self.voice_connection_attempts = 0
        
        # Setup
        self._setup_events()
        self._setup_commands()
    
    def _setup_events(self):
        """Setup Discord events"""
        
        @self.bot.event
        async def on_ready():
            logger.info(f"Discord Bot logged in as {self.bot.user.name} (id={self.bot.user.id})")
            
            # Auto join voice channel
            if self.auto_join_voice:
                await self._auto_join_voice()
            
            # Start voice reconnect monitor
            self.voice_reconnect_task = asyncio.create_task(self._voice_reconnect_monitor())
        
        @self.bot.event
        async def on_message(message):
            if message.author.bot:
                return
            
            # Process commands
            if message.content.startswith(self.bot.command_prefix):
                await self.bot.process_commands(message)
                return
            
            # Text message ‚Üí Queue
            if not message.guild:
                return
            
            queued_msg = QueuedMessage(
                text=message.content,
                source=MessageSource.DISCORD_TEXT,
                user=str(message.author.id),
                timestamp=asyncio.get_event_loop().time(),
                metadata={
                    "username": message.author.name,
                    "channel": message.channel,
                    "voice_client": self.voice_client
                }
            )
            await self.queue_manager.add_message(queued_msg)
        
        @self.bot.event
        async def on_voice_state_update(member, before, after):
            """‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á voice state"""
            if member.id == self.bot.user.id:
                if before.channel and not after.channel:
                    logger.warning("‚ö†Ô∏è Bot ‡∏ñ‡∏π‡∏Å disconnect ‡∏à‡∏≤‡∏Å voice channel")
                    self.voice_client = None
    
    async def _auto_join_voice(self):
        """‡πÄ‡∏Ç‡πâ‡∏≤ voice channel ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥"""
        try:
            if not self.bot.guilds:
                logger.warning("‚ö†Ô∏è Bot ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô guild ‡πÑ‡∏´‡∏ô‡πÄ‡∏•‡∏¢")
                return
            
            guild = self.bot.guilds[0]
            
            # ‡∏´‡∏≤ voice channel ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏ô‡∏≠‡∏¢‡∏π‡πà
            for channel in guild.voice_channels:
                if len(channel.members) > 0:
                    logger.info(f"üéØ ‡∏û‡∏ö voice channel: {channel.name} ({len(channel.members)} ‡∏Ñ‡∏ô)")
                    success = await self._connect_to_voice(channel)
                    if success:
                        logger.info(f"‚úÖ Auto joined voice: {channel.name}")
                        return
                    else:
                        logger.warning(f"‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤ {channel.name} ‡πÑ‡∏î‡πâ")
                        continue
            
            logger.warning("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö voice channel ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏ô‡∏≠‡∏¢‡∏π‡πà")
        
        except Exception as e:
            logger.error(f"‚ùå Auto join error: {e}", exc_info=True)
    
    async def _connect_to_voice(
        self,
        channel: discord.VoiceChannel,
        timeout: float = 15.0
    ) -> bool:
        """
        ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ voice channel ‡πÅ‡∏ö‡∏ö robust (‡πÉ‡∏ä‡πâ VoiceConnectionFixer)
        
        Args:
            channel: Voice channel ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
            timeout: Timeout ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
        
        Returns:
            True = ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à, False = ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß
        """
        try:
            # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
            if self.voice_client and self.voice_client.is_connected():
                if self.voice_client.channel.id == channel.id:
                    logger.info("‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß")
                    return True
                else:
                    # Move to new channel
                    await self.voice_client.move_to(channel)
                    logger.info(f"‚úÖ ‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ: {channel.name}")
                    self.target_voice_channel_id = channel.id
                    return True
            
            # Disconnect ‡∏Å‡πà‡∏≠‡∏ô‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
            if self.voice_client:
                try:
                    await self.voice_client.disconnect(force=True)
                except Exception:
                    pass
                self.voice_client = None
            
            logger.info(f"üìû ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠: {channel.name}...")
            self.voice_connection_attempts += 1
            
            # ‡πÉ‡∏ä‡πâ VoiceConnectionFixer
            self.voice_client = await VoiceConnectionFixer.robust_voice_connect(
                channel,
                timeout=timeout,
                max_retries=3
            )
            
            if self.voice_client:
                self.target_voice_channel_id = channel.id
                self.last_voice_error = None
                self.last_voice_close_code = None
                logger.info(f"‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: {channel.name}")
                return True
            else:
                logger.error("‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÑ‡∏î‡πâ")
                return False
        
        except discord.errors.ClientException as e:
            # Error 4006 handling
            if "4006" in str(e):
                self.last_voice_close_code = 4006
                self.last_voice_error = str(e)
                logger.error("‚ùå Voice invalid session (4006) ‚Äî cleaned up. Will retry later.")
                
                # Cleanup
                if self.voice_client:
                    try:
                        await self.voice_client.disconnect(force=True)
                    except Exception:
                        pass
                    self.voice_client = None
                
                return False
            else:
                logger.error(f"‚ùå Client error: {e}")
                return False
        
        except Exception as e:
            logger.error(f"‚ùå Connection error: {e}", exc_info=True)
            return False
    
    async def _voice_reconnect_monitor(self):
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞ reconnect voice ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥"""
        logger.info("üîÑ Voice reconnect monitor ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô")
        
        while True:
            try:
                await asyncio.sleep(15)  # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ó‡∏∏‡∏Å 15 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
                
                # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ target channel = ‡∏Ç‡πâ‡∏≤‡∏°
                if not self.target_voice_channel_id:
                    continue
                
                # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏¢‡∏π‡πà = ‡∏Ç‡πâ‡∏≤‡∏°
                if self.voice_client and self.voice_client.is_connected():
                    continue
                
                # ‡∏ñ‡πâ‡∏≤‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô 5 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á = ‡∏´‡∏¢‡∏∏‡∏î retry
                if self.voice_connection_attempts > 5:
                    logger.warning("‚ö†Ô∏è Voice connection failed too many times. Stopped auto-retry.")
                    logger.warning("üí° Use !join to retry manually")
                    continue
                
                # Reconnect
                logger.warning("‚ö†Ô∏è Voice connection ‡∏´‡∏•‡∏∏‡∏î ‡∏Å‡∏≥‡∏•‡∏±‡∏á reconnect...")
                
                channel = self.bot.get_channel(self.target_voice_channel_id)
                if channel:
                    await self._connect_to_voice(channel)
            
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"‚ùå Reconnect monitor error: {e}")
    
    def _setup_commands(self):
        """Setup commands"""
        
        @self.bot.command(name='join')
        async def join_voice(ctx):
            """‡πÄ‡∏Ç‡πâ‡∏≤ voice channel"""
            if not ctx.author.voice:
                await ctx.send("‚ùå ‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô voice channel ‡∏Å‡πà‡∏≠‡∏ô")
                return
            
            channel = ctx.author.voice.channel
            success = await self._connect_to_voice(channel)
            
            if success:
                await ctx.send(f"‚úÖ ‡πÄ‡∏Ç‡πâ‡∏≤ voice: {channel.name}")
            else:
                error_msg = "‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤ voice ‡πÑ‡∏î‡πâ"
                
                if self.last_voice_close_code == 4006:
                    error_msg += "\n‚ö†Ô∏è Error 4006 (Invalid Session) detected."
                    error_msg += "\nüí° Possible causes:"
                    error_msg += "\n   - Windows Firewall blocking UDP"
                    error_msg += "\n   - Missing PyNaCl: `pip install PyNaCl`"
                    error_msg += "\n   - Network/Router blocking Discord voice"
                    error_msg += "\n\nTry: `!voicelog` for details"
                
                await ctx.send(error_msg)
        
        @self.bot.command(name='leave')
        async def leave_voice(ctx):
            """‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å voice"""
            if self.voice_client:
                await self.voice_client.disconnect()
                self.voice_client = None
                self.target_voice_channel_id = None
                self.voice_connection_attempts = 0
                await ctx.send("üëã ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å voice ‡πÅ‡∏•‡πâ‡∏ß")
            else:
                await ctx.send("‚ùå ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô voice")
        
        @self.bot.command(name='speak')
        async def speak_test(ctx, *, text: str):
            """‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏û‡∏π‡∏î"""
            if not self.voice_client or not self.voice_client.is_connected():
                await ctx.send("‚ùå Bot ‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô voice ‡∏Å‡πà‡∏≠‡∏ô (‡πÉ‡∏ä‡πâ !join)")
                return
            
            await ctx.send(f"üí¨ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏π‡∏î: {text}")
            
            queued_msg = QueuedMessage(
                text=text,
                source=MessageSource.DISCORD_TEXT,
                user=str(ctx.author.id),
                timestamp=asyncio.get_event_loop().time(),
                metadata={
                    "username": ctx.author.name,
                    "channel": ctx.channel,
                    "voice_client": self.voice_client
                }
            )
            await self.queue_manager.add_message(queued_msg)
        
        @self.bot.command(name='voicelog')
        async def voice_log(ctx):
            """‡∏î‡∏π voice connection log"""
            voice_status = "‚úÖ Connected" if (self.voice_client and self.voice_client.is_connected()) else "‚ùå Disconnected"
            
            log_msg = f"""
üìä **Voice Connection Status**

**Status:** {voice_status}
**Connection Attempts:** {self.voice_connection_attempts}
**Last Error Code:** {self.last_voice_close_code or 'None'}
**Last Error:** {self.last_voice_error or 'None'}

**Target Channel ID:** {self.target_voice_channel_id or 'None'}
"""
            
            if self.last_voice_close_code == 4006:
                log_msg += """
‚ö†Ô∏è **Error 4006 Detected**

**Possible Solutions:**
1. Install PyNaCl: `pip install PyNaCl opuslib`
2. Add Windows Firewall rule for Python UDP
3. Try different network (mobile hotspot)
4. Check bot permissions (Connect, Speak)
5. Use `!diagnose` to run full diagnostics
"""
            
            await ctx.send(log_msg)
        
        @self.bot.command(name='diagnose')
        async def diagnose(ctx):
            """‡∏ß‡∏¥‡∏ô‡∏¥‡∏à‡∏â‡∏±‡∏¢‡∏õ‡∏±‡∏ç‡∏´‡∏≤ voice"""
            await ctx.send("üîç ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ß‡∏¥‡∏ô‡∏¥‡∏à‡∏â‡∏±‡∏¢‡∏õ‡∏±‡∏ç‡∏´‡∏≤...")
            
            issues = VoiceConnectionFixer.check_voice_dependencies()
            
            if not issues:
                await ctx.send("‚úÖ ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏õ‡∏±‡∏ç‡∏´‡∏≤ dependencies")
            else:
                msg = "‚ùå ‡∏û‡∏ö‡∏õ‡∏±‡∏ç‡∏´‡∏≤:\n"
                for issue in issues:
                    msg += f"   {issue}\n"
                msg += "\nüí° ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: `pip install PyNaCl opuslib`"
                await ctx.send(msg)
        
        # Admin commands
        @self.bot.command(name='status')
        async def show_status(ctx):
            if not self.admin_handler.is_admin(str(ctx.author.id)):
                return
            
            voice_status = "‚úÖ Connected" if (self.voice_client and self.voice_client.is_connected()) else "‚ùå Disconnected"
            queue_status = self.queue_manager.get_status()
            
            status_msg = f"""
üìä **‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö**
- Voice: {voice_status}
- Queue: {queue_status['queue_size']} ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
- Processing: {'‚úÖ' if queue_status['is_processing'] else '‚ùå'}
- Total Processed: {queue_status['total_processed']}
- Errors: {queue_status['total_errors']}
"""
            await ctx.send(status_msg)
    
    async def play_audio_response(
        self,
        voice_client: discord.VoiceClient,
        audio_file: str,
        text: str
    ) -> bool:
        """‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏° lip sync"""
        if not voice_client or not voice_client.is_connected():
            logger.error("‚ùå Voice client ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠")
            return False
        
        try:
            success = await self.audio_player.play_audio_with_lipsync(
                voice_client,
                audio_file,
                text
            )
            return success
        except Exception as e:
            logger.error(f"‚ùå Play audio error: {e}", exc_info=True)
            return False
    
    async def start(self):
        """‡πÄ‡∏£‡∏¥‡πà‡∏° bot"""
        try:
            logger.info("üöÄ Starting Discord bot...")
            await self.bot.start(self.token)
        except Exception as e:
            logger.error(f"‚ùå Discord bot error: {e}", exc_info=True)
    
    async def stop(self):
        """‡∏´‡∏¢‡∏∏‡∏î bot"""
        try:
            if self.voice_reconnect_task:
                self.voice_reconnect_task.cancel()
                try:
                    await self.voice_reconnect_task
                except asyncio.CancelledError:
                    pass
            
            if self.voice_client:
                await self.voice_client.disconnect()
            
            await self.bot.close()
            logger.info("‚úÖ Discord bot stopped")
        except Exception as e:
            logger.error(f"‚ùå Stop error: {e}")


def create_discord_bot(
    token: str,
    motion_controller=None,
    stt_system=None,
    auto_join_voice: bool = True
) -> DiscordBot:
    """‡∏™‡∏£‡πâ‡∏≤‡∏á Discord bot"""
    return DiscordBot(
        token=token,
        motion_controller=motion_controller,
        stt_system=stt_system,
        auto_join_voice=auto_join_voice
    )