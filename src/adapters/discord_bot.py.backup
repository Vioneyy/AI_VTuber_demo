"""
Discord Bot Adapter - Fixed Voice Reception
‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç:
1. ‡∏£‡∏±‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ã‡πâ‡∏≥‡πÜ ‡∏£‡∏±‡∏ß‡πÜ
2. Voice activity detection
3. Proper audio buffering
"""
import discord
from discord.ext import commands, voice_recv
import asyncio
import logging
from typing import Optional, Callable
import io
import time
import numpy as np

logger = logging.getLogger(__name__)

class DiscordBotAdapter:
    """Discord Bot with fixed voice reception"""
    
    def __init__(self, token: str, admin_ids: set):
        """Initialize bot"""
        intents = discord.Intents.default()
        intents.message_content = True
        intents.voice_states = True
        intents.guilds = True
        intents.members = True
        
        self.bot = commands.Bot(
            command_prefix='!',
            intents=intents,
            help_command=None
        )
        
        self.token = token
        self.admin_ids = admin_ids
        
        # Callbacks
        self.on_voice_input: Optional[Callable] = None
        
        # Voice state
        self.is_recording = False
        self.voice_client: Optional[discord.VoiceClient] = None
        
        # Voice activity detection
        self.user_audio_buffers = {}  # user_id -> audio_buffer
        self.user_last_voice = {}  # user_id -> timestamp
        self.silence_threshold = 1.0  # ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ - ‡∏ñ‡πâ‡∏≤‡πÄ‡∏á‡∏µ‡∏¢‡∏ö‡∏ô‡∏≤‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏ô‡∏µ‡πâ‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏û‡∏π‡∏î‡∏à‡∏ö
        self.min_audio_duration = 0.5  # ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ - ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏±‡πâ‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏™‡πà‡∏á
        
        # Prevent duplicate processing
        self.processing_users = set()  # users currently being processed
        
        self._register_events()
        self._register_commands()
        
        logger.info("‚úÖ Discord Bot initialized")
    
    def _register_events(self):
        """Register bot events"""
        
        @self.bot.event
        async def on_ready():
            """Bot ready"""
            logger.info(f"‚úÖ Discord Bot ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏•‡πâ‡∏ß: {self.bot.user}")
            await self.bot.change_presence(
                activity=discord.Activity(
                    type=discord.ActivityType.listening,
                    name="üé§ ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á"
                )
            )
        
        @self.bot.event
        async def on_voice_state_update(member, before, after):
            """Voice state changed"""
            if member == self.bot.user:
                if before.channel and not after.channel:
                    logger.info("üëã ‡∏ñ‡∏π‡∏Å disconnect ‡∏à‡∏≤‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á")
                    self.voice_client = None
                    self.is_recording = False
                    self._clear_audio_buffers()
    
    def _register_commands(self):
        """Register commands"""
        
        @self.bot.command(name='join')
        async def join(ctx):
            """‡πÄ‡∏Ç‡πâ‡∏≤‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á"""
            try:
                if not ctx.author.voice:
                    await ctx.send("‚ùå ‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡πà‡∏∞!")
                    return
                
                channel = ctx.author.voice.channel
                
                # Disconnect ‡∏Å‡πà‡∏≠‡∏ô‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
                if self.voice_client:
                    try:
                        await self.voice_client.disconnect(force=True)
                    except:
                        pass
                    self.voice_client = None
                    await asyncio.sleep(1)
                
                # Connect
                self.voice_client = await channel.connect(
                    timeout=10.0,
                    reconnect=False
                )
                
                logger.info(f"‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏´‡πâ‡∏≠‡∏á: {channel.name}")
                await ctx.send(f"‚úÖ ‡πÄ‡∏Ç‡πâ‡∏≤‡∏´‡πâ‡∏≠‡∏á {channel.name} ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏∞!")
                
                # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á
                await self._start_listening()
                
            except Exception as e:
                logger.error(f"Error in join: {e}")
                await ctx.send(f"‚ùå Error: {e}")
        
        @self.bot.command(name='leave')
        async def leave(ctx):
            """‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á"""
            if not self.voice_client:
                await ctx.send("‚ùå ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Ñ‡πà‡∏∞")
                return
            
            try:
                await self.voice_client.disconnect(force=True)
                self.voice_client = None
                self.is_recording = False
                self._clear_audio_buffers()
                logger.info("üëã ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á")
                await ctx.send("üëã ‡∏ö‡∏≤‡∏¢‡∏ö‡∏≤‡∏¢~")
            except Exception as e:
                logger.error(f"Error leaving: {e}")
        
        @self.bot.command(name='test')
        async def test(ctx):
            """‡∏ó‡∏î‡∏™‡∏≠‡∏ö"""
            await ctx.send("‚úÖ ‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥‡∏Ñ‡πà‡∏∞!")
    
    async def _start_listening(self):
        """‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á"""
        if not self.voice_client:
            return
        
        self.is_recording = True
        self._clear_audio_buffers()
        
        logger.info("üëÇ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á...")
        
        # Create callback sink
        def voice_callback(user, data):
            """Callback ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á"""
            if not self.is_recording:
                return
            
            # Ignore bot
            if user.bot:
                return
            
            # Buffer audio
            asyncio.create_task(self._buffer_audio(user, data))
        
        # Start recording
        self.voice_client.listen(voice_recv.BasicSink(voice_callback))
    
    async def _buffer_audio(self, user, audio_data: voice_recv.VoiceData):
        """
        Buffer audio ‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ß‡πà‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏û‡∏π‡∏î‡∏à‡∏ö‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
        """
        user_id = str(user.id)
        current_time = time.time()
        
        # Initialize buffer
        if user_id not in self.user_audio_buffers:
            self.user_audio_buffers[user_id] = bytearray()
        
        # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á process ‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        if user_id in self.processing_users:
            return  # ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏õ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏™‡∏£‡πá‡∏à
        
        # Append audio
        self.user_audio_buffers[user_id].extend(audio_data.pcm)
        self.user_last_voice[user_id] = current_time
        
        # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÄ‡∏á‡∏µ‡∏¢‡∏ö‡∏ô‡∏≤‡∏ô‡∏û‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á (‡∏´‡∏°‡∏≤‡∏¢‡∏ñ‡∏∂‡∏á‡∏û‡∏π‡∏î‡∏à‡∏ö‡πÅ‡∏•‡πâ‡∏ß)
        await asyncio.sleep(self.silence_threshold)
        
        # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ß‡πà‡∏≤‡∏¢‡∏±‡∏á‡πÄ‡∏á‡∏µ‡∏¢‡∏ö‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        if user_id in self.user_last_voice:
            time_since_last = time.time() - self.user_last_voice[user_id]
            
            if time_since_last >= self.silence_threshold:
                # ‡∏û‡∏π‡∏î‡∏à‡∏ö‡πÅ‡∏•‡πâ‡∏ß - ‡∏™‡πà‡∏á‡πÑ‡∏õ process
                await self._process_buffered_audio(user, user_id)
    
    async def _process_buffered_audio(self, user, user_id: str):
        """Process audio ‡∏ó‡∏µ‡πà buffer ‡πÑ‡∏ß‡πâ"""
        try:
            # ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£ process ‡∏ã‡πâ‡∏≥
            if user_id in self.processing_users:
                return
            
            self.processing_users.add(user_id)
            
            # Get buffered audio
            if user_id not in self.user_audio_buffers:
                return
            
            audio_bytes = bytes(self.user_audio_buffers[user_id])
            
            # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß
            duration = len(audio_bytes) / (48000 * 2 * 2)  # 48kHz, stereo, int16
            
            if duration < self.min_audio_duration:
                logger.debug(f"Audio too short: {duration:.2f}s from {user.name}")
                return
            
            logger.info(f"üé§ Received voice from {user.name}")
            
            # Clear buffer
            del self.user_audio_buffers[user_id]
            del self.user_last_voice[user_id]
            
            # Send to callback
            if self.on_voice_input:
                await self.on_voice_input(user, audio_bytes, 48000)
            
        except Exception as e:
            logger.error(f"Error processing audio: {e}")
        finally:
            # ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ process ‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏î‡πâ
            if user_id in self.processing_users:
                self.processing_users.remove(user_id)
    
    def _clear_audio_buffers(self):
        """‡∏•‡πâ‡∏≤‡∏á audio buffers"""
        self.user_audio_buffers.clear()
        self.user_last_voice.clear()
        self.processing_users.clear()
    
    async def play_audio(self, audio_data: np.ndarray, sample_rate: int):
        """‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á"""
        if not self.voice_client or not self.voice_client.is_connected():
            logger.warning("‚ö†Ô∏è  ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ voice channel")
            return
        
        try:
            # ‡πÅ‡∏õ‡∏•‡∏á numpy array ‡πÄ‡∏õ‡πá‡∏ô audio source
            audio_source = NumpyAudioSource(audio_data, sample_rate)
            
            # ‡∏£‡∏≠‡∏ñ‡πâ‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏¢‡∏π‡πà
            while self.voice_client.is_playing():
                await asyncio.sleep(0.1)
            
            # ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á
            self.voice_client.play(audio_source)
            
            logger.info("üîä Playing audio...")
            
            # ‡∏£‡∏≠‡∏à‡∏ô‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à
            while self.voice_client.is_playing():
                await asyncio.sleep(0.1)
            
            logger.info("‚úÖ Audio playback completed")
            
        except Exception as e:
            logger.error(f"Error playing audio: {e}", exc_info=True)
    
    async def start(self):
        """Start bot"""
        try:
            await self.bot.start(self.token)
        except Exception as e:
            logger.error(f"Failed to start bot: {e}")
            raise
    
    async def stop(self):
        """Stop bot"""
        try:
            self.is_recording = False
            self._clear_audio_buffers()
            
            if self.voice_client:
                await self.voice_client.disconnect(force=True)
            
            await self.bot.close()
            logger.info("üëã Discord Bot stopped")
        except Exception as e:
            logger.error(f"Error stopping bot: {e}")


class NumpyAudioSource(discord.AudioSource):
    """Audio source ‡∏à‡∏≤‡∏Å numpy array"""
    
    def __init__(self, audio_data: np.ndarray, sample_rate: int):
        """
        Args:
            audio_data: Audio data (numpy array, float32)
            sample_rate: Sample rate
        """
        # Resample to 48kHz (Discord requirement)
        if sample_rate != 48000:
            from scipy import signal
            audio_data = signal.resample(
                audio_data,
                int(len(audio_data) * 48000 / sample_rate)
            )
        
        # Ensure in range [-1, 1]
        max_val = np.abs(audio_data).max()
        if max_val > 0:
            audio_data = audio_data / max_val * 0.95
        
        # Convert to int16
        audio_data = np.clip(audio_data, -1.0, 1.0)
        audio_data = (audio_data * 32767).astype(np.int16)
        
        # Convert to bytes
        self.audio_bytes = audio_data.tobytes()
        self.position = 0
        
        # Discord expects 20ms frames at 48kHz
        # 48000 samples/sec * 0.02 sec = 960 samples
        # 960 samples * 2 bytes = 1920 bytes per frame
        self.frame_size = 1920
    
    def read(self) -> bytes:
        """Read next audio frame"""
        if self.position >= len(self.audio_bytes):
            return b''
        
        frame = self.audio_bytes[self.position:self.position + self.frame_size]
        self.position += self.frame_size
        
        # Pad if needed
        if len(frame) < self.frame_size:
            frame += b'\x00' * (self.frame_size - len(frame))
        
        return frame
    
    def is_opus(self) -> bool:
        """Not Opus encoded"""
        return False